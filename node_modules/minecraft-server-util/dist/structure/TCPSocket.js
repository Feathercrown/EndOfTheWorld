"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const net_1 = __importDefault(require("net"));
const Packet_1 = __importDefault(require("./Packet"));
/**
 * A TCP socket utility class for easily interacting with remote sockets.
 * @class
 */
class TCPSocket {
    /**
     * Creates a new TCP socket class from the existing connection.
     * @param {net.Socket} socket The existing TCP connection
     * @constructor
     */
    constructor(socket) {
        /**
         * A boolean that indicates whether the socket is connected or not.
         * @type {boolean}
         */
        this.isConnected = false;
        this.buffer = [];
        this.socket = socket;
        socket.on('data', (data) => {
            this.buffer.push(...Array.from(data));
        });
    }
    /**
     * Automatically connects to the server using the host and port.
     * @param {string} host The host of the server
     * @param {number} port The port of the server
     * @param {number} timeout The timeout in milliseconds
     * @returns {Promise<TCPSocket>} A Promise that resolves to the TCP socket
     * @async
     */
    static connect(host, port, timeout) {
        assert_1.default(host.length > 0, 'Expected host.length > 0, got ' + host.length);
        assert_1.default(Number.isInteger(port), 'Expected integer, got ' + port);
        assert_1.default(port > 0, 'Expected port > 0, got ' + port);
        assert_1.default(port < 65536, 'Expected port < 65536, got ' + port);
        assert_1.default(timeout > 0, 'Expected timeout > 0, got ' + timeout);
        const socket = net_1.default.createConnection({ host, port, timeout });
        return new Promise((resolve, reject) => {
            const connectHandler = () => {
                resolve(new TCPSocket(socket));
                socket.removeListener('connect', connectHandler);
            };
            const closeHandler = () => {
                reject();
                socket.removeListener('close', closeHandler);
            };
            const endHandler = () => {
                reject();
                socket.removeListener('end', endHandler);
            };
            const errorHandler = (error) => {
                reject(error);
                socket.removeListener('error', errorHandler);
            };
            const timeoutHandler = () => {
                reject();
                socket.removeListener('timeout', timeoutHandler);
            };
            socket.on('connect', connectHandler);
            socket.on('close', closeHandler);
            socket.on('end', endHandler);
            socket.on('error', errorHandler);
            socket.on('timeout', timeoutHandler);
        });
    }
    /**
     * Reads a byte from the stream.
     * @returns {Promise<number>} The byte read from the stream
     * @async
     */
    readByte() {
        if (this.buffer.length > 0) {
            return Promise.resolve(this.buffer.shift() || 0);
        }
        return new Promise((resolve) => {
            let read = false;
            const dataHandler = () => {
                if (read) {
                    return;
                }
                process.nextTick(() => {
                    if (this.buffer.length > 0) {
                        read = true;
                        this.socket.removeListener('data', dataHandler);
                        return resolve(this.buffer.shift());
                    }
                });
            };
            this.socket.on('data', dataHandler);
        });
    }
    /**
     * Read bytes from the stream.
     * @param {number} length The amount of bytes to read
     * @returns {Promise<number[]>} The bytes read from the stream
     * @async
     */
    readBytes(length) {
        if (this.buffer.length >= length) {
            const value = this.buffer.slice(0, length);
            this.buffer.splice(0, length);
            return Promise.resolve(value);
        }
        return new Promise((resolve) => {
            let read = false;
            const dataHandler = () => {
                if (read) {
                    return;
                }
                process.nextTick(() => {
                    if (this.buffer.length >= length) {
                        read = true;
                        this.socket.removeListener('data', dataHandler);
                        const value = this.buffer.slice(0, length);
                        this.buffer.splice(0, length);
                        return resolve(value);
                    }
                });
            };
            this.socket.on('data', dataHandler);
        });
    }
    /**
     * Read a varint from the stream.
     * @returns {Promise<number>} The varint read from the stream
     * @async
     */
    readVarInt() {
        return __awaiter(this, void 0, void 0, function* () {
            let numRead = 0;
            let result = 0;
            let read, value;
            do {
                if (numRead > 4) {
                    throw new Error('VarInt exceeds data bounds');
                }
                read = yield this.readByte();
                value = (read & 0b01111111);
                result |= (value << (7 * numRead));
                numRead++;
                if (numRead > 5) {
                    throw new Error('VarInt is too big');
                }
            } while ((read & 0b10000000) != 0);
            return result;
        });
    }
    /**
     * Reads a short (int16, big-endian) from the stream.
     * @returns {Promise<number>} The int16 read from the stream
     * @async
     */
    readShort() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(2);
            return (data[0] << 8) | data[1];
        });
    }
    /**
     * Reads a short (int16, little-endian) from the stream.
     * @returns {Promise<number>} The int16 read from the stream
     * @async
     */
    readIntLE() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(4);
            return data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
        });
    }
    /**
     * Writes bytes to the stream.
     * @param {Buffer} buffer The buffer to write to the stream.
     * @returns {Promise<void>} The Promise that resolves when it has successfully written the data
     * @async
     */
    writeBytes(buffer) {
        return new Promise((resolve, reject) => {
            this.socket.write(buffer, (error) => {
                if (error) {
                    return reject(error);
                }
                resolve();
            });
        });
    }
    /**
     * Writes a {@see Packet} to the stream.
     * @param {Packet} packet The Packet to write to the stream
     * @param {boolean} [prefixLength=true] Write the packet length as a prefix as a varint
     * @returns {Promise<void>} The Promise that resolves when the packet has been written
     * @async
     */
    writePacket(packet, prefixLength = true) {
        if (prefixLength) {
            const finalPacket = new Packet_1.default();
            finalPacket.writeVarInt(packet.data.length);
            finalPacket.writeByte(...packet.data);
            return this.writeBytes(Buffer.from(finalPacket.data));
        }
        return this.writeBytes(Buffer.from(packet.data));
    }
    /**
     * Closes the stream and cleans up data.
     * @returns {Promise<void>} The Promise that resolves when the connection has closed
     * @async
     */
    destroy() {
        return new Promise((resolve) => {
            this.socket.removeAllListeners();
            this.socket.end(() => {
                resolve();
                this.socket.destroy();
            });
        });
    }
}
exports.default = TCPSocket;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVENQU29ja2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0cnVjdHVyZS9UQ1BTb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsOENBQXNCO0FBQ3RCLHNEQUE4QjtBQUU5Qjs7O0dBR0c7QUFDSCxNQUFNLFNBQVM7SUFhZDs7OztPQUlHO0lBQ0gsWUFBWSxNQUFrQjtRQVo5Qjs7O1dBR0c7UUFDSSxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUNuQixXQUFNLEdBQWEsRUFBRSxDQUFDO1FBUTdCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXJCLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBWSxFQUFFLElBQVksRUFBRSxPQUFlO1FBQ3pELGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsZ0NBQWdDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hFLGdCQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSx3QkFBd0IsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNoRSxnQkFBTSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUseUJBQXlCLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDbkQsZ0JBQU0sQ0FBQyxJQUFJLEdBQUcsS0FBSyxFQUFFLDZCQUE2QixHQUFHLElBQUksQ0FBQyxDQUFDO1FBQzNELGdCQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSw0QkFBNEIs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